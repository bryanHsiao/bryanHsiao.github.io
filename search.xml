<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript - 更進一步]]></title>
    <url>%2F2019%2F08%2F03%2FJS-JS_Next%2F</url>
    <content type="text"><![CDATA[Pmroise , async_await … call back補充:https://cythilya.github.io/2018/10/30/callback/ Synchronous vs Asynchronous顧客：阻塞(憨厚) vs 非阻塞(變通) polling老闆：同步(臭跩) vs 非同步(親切)ex:公司報到+銀行開戶避免過度阻塞 pollinglongpollingstreaming (websocket)補充：https://blog.niclin.tw/2017/10/28/%E7%8D%B2%E5%BE%97%E5%AF%A6%E6%99%82%E6%9B%B4%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95polling-comet-long-polling-websocket/ https://blog.gtwang.org/web-development/websocket-protocol/ 補充：https://johlmike.wordpress.com/2016/07/08/%E5%90%8C%E6%AD%A5synchronous%E3%80%81%E7%95%B0%E6%AD%A5asynchronous%E3%80%81%E9%98%BB%E5%A1%9Eblock%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9Enon-block/阻塞與非阻塞主要是描述請求在等待結果時的狀態同步與異步主要是描述回傳的聯絡方式 非同步有1.setInterval setTimeout 2.一般的 eventhandler3.server 的呼叫 佇列、堆疊、事件循環佇列(Queue)：先進先出 ex：排隊、jQuery 動畫堆疊(Stack)：後進先出 ex：河內塔事件循環(Event Loop):從佇列提取到堆疊執行補充:https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html 非同步處理:主流程處理完後處理Stack 不清空，Queue 是無法往下做的補充：https://ithelp.ithome.com.tw/articles/10200054?sc=iThelpRloupe：http://latentflip.com/loupe/ 123456789101112131415161718192021222324252627function A()&#123; setTimeout(() =&gt; &#123; console.log('A') &#125;, 1000)&#125;function B()&#123; setTimeout(() =&gt; &#123; console.log(B') &#125;, 500)&#125;function C()&#123; setTimeout(() =&gt; &#123; console.log('C') &#125;, 2000)&#125;// B A CA()B()C()// 不好的寫法A()setTimeout(B,1000)setTimeout(C,1500) 1234567891011121314151617181920log('=====start=====')log('a');log('b');while (pass() &lt; 5000) &#123;&#125;log('c');``log('====`=end=====')const timerHandler = () =&gt; &#123; pass() &lt; 5000 ? setTimeout(timerHandler, 0) : log('timer ok');&#125;;log('=====start=====')log('a');log('b');while (pass() &lt; 5000) &#123;&#125;setTimeout(timerHandler, 0);log('c');log('=====end=====') +new Date() 等同於 new Date().getTime()不要用 Timer 控流程，時間不準 123456789101112131415"MY_ROOM": &#123; "prefix": "room", "body": [ "const time = +new Date();", "const pass = () =&gt; +new Date() - time;", "const log = msg =&gt; &#123;", "console.log(msg, `$&#123;pass()&#125;ms`);", "&#125;;", "", "log('===== Start =====');", "$1", "log('===== End =====');" ], "description": "MY_ROOM"&#125; Promise(1) 可以做同步組合(2) Queue 在不同瀏覽器可能會有不同表現 12345678910111213141516171819202122232425262728const promise = (time, msg) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; log(`Promise Create: $&#123;msg&#125;`); if (time &lt;= 0) &#123; resolve(`Promise OK: $&#123;msg&#125;`); &#125; else &#123; setTimeout(() =&gt; &#123; resolve(`Promise OK: $&#123;msg&#125;`); &#125;, time); &#125; &#125;);&#125;;// 觀戰重點1： Promise: 同步 then:非同步log("==== A ====");promise(0, "A").then(result =&gt; log(result));log("==== B ====");promise(1000, "B").then(result =&gt; log(result));log("==== B ====");promise(500, "C").then(result =&gt; log(result));// 觀戰重點2: stack 阻塞while (pass() &lt; 2000) &#123;&#125;// 觀戰重點3: timeout人權議題setTimeout(() =&gt; &#123; log("timer");&#125;, 0);log("==== A ====");promise(0, "A").then(result =&gt; log(result)); promise：等到允許授權才能往下走then 須等到 resolve 1234567891011121314// 觀戰重點4: 執行順序，將同步非同步變成依序執行// 如果再then裡catch會往下走，如果沒有就不會再往下走promise(0, "A") .then( result =&gt; log(result), error =&gt; log(`error:$&#123;error&#125;`) ) .then(result =&gt; promise(3000, "B")) .then(result =&gt; log(result)) .then(result =&gt; promise(0, "C")) .then(result =&gt; log(result)) .then(result =&gt; promise(2000, "D")) .then(result =&gt; log(result)) .catch(error =&gt; log(`error:$&#123;error&#125;`)); 12345678910111213141516171819202122232425log("===== Start =====");// if timer ?promise(0, "A") .then( result =&gt; log(result), error =&gt; log(`error:$&#123;error&#125;`) ) // .catch(error =&gt; log(`error:$&#123;error&#125;`)) .then(result =&gt; promise(3000, "B")) .then(result =&gt; log(result)) .then(result =&gt; promise(0, "C")) .then(result =&gt; log(result)) .then(result =&gt; promise(2000, "D")) .then(result =&gt; log(result)) .catch(error =&gt; log(`error:$&#123;error&#125;`)) .then(result =&gt; log(result)); // finallog("===== End =====");// if blocking ?// example 讀取API資料// 1.使用者觸發 -&gt; 2.loading(true) -&gt; 3.發出請求 -&gt; 4.結果回應 -&gt; 5.loading(false) 12345678910setTimeout(() =&gt; &#123; log("timer");&#125;, 0);log("==== A ====");promise(0, "A").then(result =&gt; log(result));// log("==== B ====");// promise(1000, "B").then(result =&gt; log(result));// log("==== C ====");// promise(500, "C").then(result =&gt; log(result));// while (pass() &lt; 2000) &#123;&#125; finallyhttps://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Control_flow_and_error_handlinghttps://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally 123456789101112131415function f() &#123; try &#123; log(1); return 1; &#125; catch (e) &#123; log(2); return 2; &#125; finally &#123; log(3); return 3; &#125; log(4); return 4;&#125;f(); 後進先出範例 12345678910111213141516後進先出;function A() &#123; console.log("A");&#125;function B() &#123; A(); console.log("B");&#125;function C() &#123; B(); console.log("C");&#125;C(); Pmroise.all vs Promise.raceall：全部一起做，時間最長的race:只取最快回來的資料 1234567891011Promise.all([ promise(0, "A") .then(result =&gt; result) .catch(result =&gt; result), promise(3000, "B") .then(result =&gt; result) .catch(result =&gt; result), promise(2000, "C") .then(result =&gt; result) .catch(result =&gt; result)]).then(result =&gt; log(`all $&#123;result&#125;`)); Generatorfunction*()會自動產生 return建議為每個 function 做適當的 return 值 Generaor+Promise 的範例(async await 的前身) 12345678910111213141516let gen = genFn();gen .next() .value.then(result =&gt; gen.next(result)) .then(result =&gt; result.value) .then(result =&gt; gen.next(result)) .then(result =&gt; result.value) .then(result =&gt; gen.next(result)) .then(result =&gt; log(result));//每個next都是做一個 create promise//1~2 &#123;value:Promise A, done:false&#125;//4 &#123;value:Promise B, done:false&#125;//6 &#123;value:Promise C, done:false&#125;//8 &#123;value:&#123;&#125;, done:true&#125; 補充:所有 function 都應該有 return，沒有 return 他就是 undefined如果是事件觸發，那 return 值就會沒人會使用到 async_awaitasync =&gt; 非同步 , await =&gt; 等async await =&gt; 等非同步 補充:7.1 await 只能存在 async function 裡面7.2 await 必須等非同步(必須等非同步(promise)) 重要:先讓 promise 做完(同步)，再一起 await，不要一邊 promise，一邊 await，因為會讓同步的 promise 的同步做成非同步的 12345678(async function() &#123; let result = &#123;&#125;; resule["A"] = await promise(0, "A"); resule["B"] = await promise(3000, "B"); resule["C"] = await promise(2000, "C"); console.log(result);&#125;)(); 12345678910111213141516171819202122(async function() &#123; let A = promise(0, "A"); //promise let B = promise(3000, "B"); let C = promise(2000, "C"); //1. await A; await B; await C; let result = &#123; A, B, C &#125;; //or //2. let result = &#123; A: await A, //result B: await B, C: await C &#125;; log(result);&#125;)(); async function 裡面有 await await 等 async functionawait 等 promise async_array同一個作用域裡，await 才會互等 1234567891011(async function() &#123; Array.prototype.asyncEach() = anync function(handler) &#123; for(let i = 0; i &lt; this.length; i++) &#123; await handler(this[i], i, this); &#125; &#125; data.asyncEach(async item =&gt; &#123; log(await promise(Math.random() * 10, item)); //同步指令只有第一次，之後都是一個一個等(非同步) &#125;);&#125;)(); 補充:大部分有用的 this 時候都會用 function，大部分第二層就會用箭頭函式，setTimeout，就會往外找，找到上一層的對象(document) 12345document.addEventListener("xxx", function() &#123; setTimeout(() =&gt; &#123; this; &#125;, 0);&#125;); API(1) 販賣機NG-1 吃錢NG-2 給錯東西=&gt; 給正確的東西 (2) 拉麵販賣機打對的網址(按對的按鈕)給正確的查詢回正確的資料(固定有規範的輸入與輸出) JSONJavaScript Object Notation最上層建議:物件 Restful API : Representational State Transfer Read：GET 讀取紀錄Create：POST 新增紀錄Update：PUT/PATCH 修改紀錄Delete：DELETE 刪除紀錄 Http Status Code：//ok =&gt; then2xx：這是您要的東西3xx：請稍後為您轉接//error =&gt; catch4xx：請查明後再撥5xx：嘟~嘟~嘟~ TCP 三次握手與四次揮手C:Client S:Server傳輸前:三次握手(確認雙方都在)1 C:安安,你好!住哪?給虧嗎? =&gt; 尋找目標 Server2 S:台北,28 =&gt; Server 回應3 C:好巧喔!我也住台北 =&gt; Client 也回應 雙方連上線開始傳輸 離開前:四次揮手1 C：我要去洗澡了 =&gt; 我要結束了(C)2 S：等一下 =&gt; 確認是否還有未傳完(S)3 S：我去洗澡 (雙重攻擊) =&gt; 傳完我要結束了(S)4 C：你就去吧 =&gt; 你可以結束了(C) 此時 Server 斷線，等待兩秒確定斷線，Client 也斷線 DoS 攻擊:大量請求，使 Server 被打到癱瘓，無法正常服務 SQL VS NOSQLSQL:關聯，查詢資料需要透過多個資料表查詢，較費時資料分散，資料較小 ( 時間換空間 )NOSQL:需要資料直接拿整包，不需要組合，較快資料較多份，資料較大 ( 空間換時間 )( Not Only SQL ) cookie vs sessionToken：令牌/通行證Storage：都存在本機Local Storage：沒有時效性，連線不會傳，不刪他不會被刪除 (長時間暫存)Session Storage：跟著 Tag(分頁)，關閉就刪除(session 連線結束 會被清掉)，存在 SERVER 端會占用 SERVER 端的資源，單次連線的暫存 儲存在 server 端(暫存檔) cookie：存在本機，使用者可以刪除，有期限的(可設計過期時間)，SERVER 在每次連線的時候會自動綁定和傳輸(目的:隨使想取用都可以做檢查)，不適手動自己加的東西 儲存在 user 端 (短期)，不建議前端操作 cookie補充:TOKEN 都會放在 cookie 為主Http Only：程式不能刪session：連線階段的操作，存在 server 端，使用者不能刪除 PUT vs PATCHPUT：傳整包，實務上後端某些欄位會鎖住(例如：ID)，相信你傳PATCH：傳部分修改資料理論上如此，但實作還是要看後端作法 範例 9 讀取資料 (讀取 api 是非同步，所以呼叫時，必須加 await，因為必須等非同步完成才 render，不然 render 時回沒有資料 render，ex:await xxx())，await 是一種等的概念，render(同步)必須等 await loadData()的概念 渲染畫面 使用者功能reduce：組合技 123456789101112const input = $(this) .serializeArray() .reduce((prev, now) =&gt; &#123; prev[now.name] = now.value; //prev[userId]="1"; //prev[body] = "aa"; return prev; &#125;, &#123;&#125;);// 1=&gt; prev = &#123;&#125;,now = &#123;name: "userId", value: "1"&#125;// 2=&gt; prev = &#123;userId:"1"&#125;, now = &#123;name: "body, value: "aa"&#125;input.userId *= 1;console.log(input); location.reload()：刷新畫面 讀取資料 =&gt; 渲染畫面 =&gt; 使用者功能可以考慮重構成下面：讀取表單資料(users) =&gt; 渲染表單 =&gt; 表單功能讀取列表資料(posts) =&gt; 渲染列表 =&gt; 列表功能 補充:form 的好工具 1const input = $(this).serializeArray(); JSONPJSON with Padding解決跨域問題 物件導向封裝:分類，然後包起來(資料 attribute+功能 Methods)繼承:爸爸有房子,我就有房子 SOLLIDS:做好分類 (單一職責(Single Responsibility PrincipleO:開放擴充 封閉修改 (開放封閉(Open-Closed PrincipleL:小孩可以代替爸爸 爸爸不能代替小孩 (里氏替換(Liskov Substitution PrincipleL:只給部分功能 (最小知識(Least Knowledge PrincipleI:不受其他介面影響 (介面隔離(Interface Segregation PrincipleD:避免小孩影響到爸爸 (依賴反轉(Dependency Inversion Principle 物件建議 判斷 this 再使用(有 new 就是你創物件本身，不然就是指向 window(全域)) 1234567891011121314151617181920212223242526272829303132333435363738const Creature = function(name, sex)&#123; if(this instanceof Creature)&#123; this.name = name || "NoName"; this.sex= sex || 0; this.life = 100; // this.intro = function()&#123; // console.log( // `My name is $&#123;this. name&#125;, I'am a $&#123;this.sex ? "man" : "woman"` // ); &#125; &#125;else&#123; return new Creature(name, sex); &#125;&#125;;Creature.prototype.intro = functionlet C1 = new Creature("Alex", 1);let C2 = Creature("Sara", 0);console.log(C1);console.log(C2);//執行結果: Creature &#123;name: "Alex", sex: 1, life: 100&#125;//自製的Creature物件console.log(C1.intro === C2.into);//執行結果:false每產生一個Creature就會多產生一個function，所以用Creature的prototype，已讓產生的Creatue物件能共用console.log(C1, C1._proto_,C1._proto_._proto_);//&#123;name: "Alex"m sex:1, life: 200&#125; Creatur&#123;intro:[Function]&#125; &#123;&#125;//原型練的定義:假設這層沒有，就會找尋上一層，直到找到盡頭找不到，就會回undefined//原型鍊的每一層皆是object function 如果是做一樣事情，建議拉到 proto 做，不然在 new 的時候會多產生 公有與私有 4.defineProperty 非常重要!! 與陣列 reduce 一樣重要defineProperty 的功能是把一個屬性轉變成 function(並分別有讀和取的功能)改成 function 的好處，他可以回傳 callback，ex: 假設有人改你的資料，就會回傳，但變數卻無法 123456789101112let _age = 30;let a = &#123; name: "alex"&#125;;Object.defineProperty(a, "age", &#123; get()&#123; return _age;&#125;);a.age++console.log(a.age);//還是是30，因為他只開get，所以不能寫入 12345678910111213//defineProperties的寫法Object.defineProperties(this, &#123; name: &#123; get() &#123; return _name; &#125; &#125;, sex: &#123; get() &#123; return _sex; &#125; &#125;&#125;); prototype 與proto的分別就是物件生成前後(ex: new Creature)，之前Creature.prototype.intro = function(){ }new 出來之後只能讀到proto，讀 prototype 會有一些問題 X 全域變數X 浮點數計算X with 與 evalX 強制轉型的雙等號X 無所不在的宣告X 無區塊的敘述式X 函式敘述與運算X 類型的包裝與 NewX 隨意換行與分號X 加號運算子X continueX switch 穿越X 分散的回傳值X 太早做過度縮寫 1234567891011121314151617let a = "A";let b = "B";let c = "C";let obj = &#123; a: 1, b: 2&#125;;with (obj) &#123; console.log(a); // 1 console.log(b); // 2 console.log(c); // C (obj.c =&gt; C =&gt; not defiend&#125;let script = "console.log(123)";eval(script); 閉包咖哩化模式工廠模式 (Factory)主力:產東西EX: Object 策略模式 (Strategy)主力:對應東西策略表(Map 表) 外觀模式 (Facade)一個 function 包很多功能EX:點青椒炒牛肉 =&gt; 處理青椒/處理牛肉/炒都交給廚師處理點餐的人不需要知道這些 觀察者模式觀察者模式 : 透過第三者溝通 EX:事件 MV*Model 資料邏輯View 畫面層 C:畫面對 Model 監聽P:畫面透過 Present 偵聽? 第三天prototype People.prototype = Creature.prototype直接賦值 prototype問題: 原本方法被取代 People.prototype = new Creature()問題: 有自己及父親的屬性，本身屬性移除就變成父親的屬性方法也會不見(多額外屬性) 繼承方法 123Function.prototype.extend = function(parent) &#123; this.prototype.__proto__ = parent.prototype;&#125;; protp : 實體化使用prototype : 未實體化 12345678910111213const Alex = function() &#123;&#125;;Alex.prototype.eat = function() &#123;&#125;;let eatShit = function() &#123;&#125;;let a1 = new Alex();// a1.__proto__ = Object.assign(&#123;&#125;,a1.__proto__, &#123;eat:eatShit&#125;)a1.__proto__ = &#123; eat: eatShit &#125;;let a2 = new Alex();console.log(a1.eat === a2.eat); // trueconsole.log(a1.eat === eatShit); // false =&gt; trueconsole.log(a2.eat === eatShit); // false 作業 : alex.lvUp(‘People’)123456const People = function(name) &#123; // Creature.apply(this, arguments) People.prototype.__proto__.constructor.apply(this, arguments);&#125;;People.extend(Creature); 與下面差異相同 123456789function A() &#123; console.log("HI");&#125;let msg = "HI";function B() &#123; console.log(msg);&#125; class class 關鍵字 construtor 初始化 static function //TODO 待補 複製 obj obj1 = {…obj} obj2 = Object.assign({},obj) obj3 = JSON.parse(JSON.stringigy(obj)) obj4 = {} Object.create() 複製 function閉包 12345function copyFunction(fun) &#123; return function() &#123; fun(); &#125;;&#125; MVC VS MVP MVCV -event-&gt; C -&gt; M -&gt; V MVPV P M MVVMV VM M MVC 主程式(拉近三個架構 App 另外三隻檔案( View/Mode/Controller Observer Alex 開發順序(參考) 先做基礎架構(App 主程式)1-1 import MVC1-2 開三支檔案1-3 做關係(new 出來 View 需要認識 ModelController 要認識 Model 跟 View 123const M = new Model();const V = new View(M);const C = new Controller(M, V); Model (資料邏輯)增加/讀取/選擇/刪除(事件)做完後打事件出去盡量不要動畫面 View (畫面邏輯:畫面偵聽/資料變動)3-1 記資料3-2 匯入 jQuery (import \$ from ‘jquery’ 盡量不要動資料 補充 call/apply/bind與 function 的 this 操作有關 1234567891011121314151617181920212223242526let A = &#123; name: 'A' fun: function(a,b) &#123; console.log(this.name,a,b) &#125;&#125;let B = &#123; name: 'B'&#125;A.fun(1,2) // A,1,2// B.fun(3,4) // B.fun is not a function// B.fun(x,y) // x is not definedA.fun.call(B,3,4) // B,3,4A.fun.apply(B,[3,4]) // B,3,4// bind會產生新functionlet fun = A.fun.bind(B,3)// 類似咖哩化 (傳滿就比較沒有意義)fun(5) // B,3,5fun(6) // B,3,6// [].map.call// Math.xxx.call show 改變畫面MVC 架構中，View 不能自己改畫面，要通知讓後面去改這邊採用畫面全部重劃較耗效能，可以嘗試修改不要整個畫面重畫 Controller (牽手=&gt;控制 Model) TODO:可以練習 switchHandler Singleton單例模式 : 閉包判斷如果產生過，就用之前產生的，沒產生過再產生新的概念類似 123let a = &#123; count: 0 &#125;;let b = a;let c = a; 練習: 繼承練習 MVC 架構修正 View 的 switch 事件 第三天下午問題討論 12345678910111213141516var out = 25, inner = &#123; out: 20, func: function() &#123; var out = 30; // 沒有用到 return this.out; &#125;, func1: function() &#123; var out = 30; return out; &#125; &#125;;console.log((inner.func, inner.func1)()); // 30console.log(inner.func()); // 20console.log(inner.func()); //20console.log((inner.func1 = inner.func)()); // undefined =&gt; 25 1234567let a = (1, 2);console.log(a); // 2let q1 = 1;let q2 = 2;let b = (q1 = q2);console.log(b); // 2 DL DT DDDL=&gt;Definition ListDT=&gt;Definition TermDD=&gt;Definition Description Observer 觀察者模式電視/收音機無時無刻都在播放，但你有沒有去看/聽 (觀察)決定會部會有回應結構:1 個持續播放,1 個監聽者功能:解耦 耦合我在你也在，我死你也死 1234567891011121314151617181920const Observer = function(host) &#123; this.b1b2 = function() &#123; this.btn1.log(); this.btn2.log(); &#125;;&#125;;const btn1 = function() &#123; this.log = function() &#123; console.log("b1 log"); &#125;;&#125;;const btn2 = function() &#123; this.log = function() &#123; console.log("b1 log"); &#125;;&#125;;const ob = new Observer(this); 改成下面，不容易在 ob 內部發生 b1/b2 錯誤//TODO 待補 123456789101112``````javascript=let timestamp = function(&#123; year, month, date, hour, min, sec &#125;) &#123; year = addZero(year, 4); month = addZero(month, 2); day = addZero(date, 2); hour = addZero(hour, 2); min = addZero(min, 2); sec = addZero(sec, 2); return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hour&#125;:$&#123;min&#125;:$&#123;sec&#125;`;&#125;; 12345678loading = true;this.XXX = XXX();this.ooo = OOO();await this.XXX;await this.ooo;loding = false;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript - 從零開始 Day2]]></title>
    <url>%2F2019%2F07%2F21%2FJS-Starting%20from%20scratch%20D2%2F</url>
    <content type="text"><![CDATA[第二天 範例 9 流程(1) 捲動 =&gt; 那一塊 =&gt; addClass(2) 按鈕 =&gt; 那一塊 =&gt; 捲動(1)(3) 回到頂端 =&gt; 捲最上(1) 卷軸往下 1px 內容往上 1px offset(全域座標) vs position(區塊座標) 寬高比較(1) width(),height() DOM 內容寬高(2) innerWidth(),innerHeight() DOM 內容寬高+padding 寬高(3) outerWidth(),outerHeight() DOM 內容寬高+padding 寬高+border 寬高(4) outerWidth(true),outerHeight(true) DOM 內容寬高+padding 寬高+border 寬高+margin 寬高 function 中斷不能用 break 要用 return false jQuery1234// 點goTop一下$("#goTop").click();// 做click事件偵聽$("#goTop").click(function() &#123;&#125;); ***forEach vs eachforEach((obj,index)=&gt;{})each((index,obj)=&gt;{}) eq : 等於 動畫 : animate normal: animate(動畫屬性,時間,加減速,完成後的 FUNCTION) advence: animate(動畫屬性,設定) *建議用第二種用法，需要打到比較多屬性英文，幫助更多了解及記憶 *事件偵聽要先有偵聽，之後才能觸發 JQUERY123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function() &#123; // 請輸入你的程式 let $contents = $("#container &gt; section"); let completeHandler = function() &#123; console.log("OK"); &#125;; // 做click事件偵聽 $("#goTop") .click(function() &#123; // 1.normal: animate(動畫屬性,時間,加減速,完成後的FUNCTION) // 2.advence: animate(動畫屬性,設定) // $("html,body").animate(&#123; scrollTop: 0 &#125;, 1000, "linear", completeHandler); $("html,body").animate( &#123; scrollTop: 0 &#125;, &#123; duration: 1000, easing: "linear" // complete: completeHandler &#125; ); &#125;) .click(); // 點goTop一下(觸發) // $("#goTop").click(); $(window) .scroll(function() &#123; let top = $(window).scrollTop() + $("#nav").outerHeight(true); let bottom = $(window).scrollTop() + $(window).height(); let target = 0; $contents.each((index, section) =&gt; &#123; let sectionTop = $(section).offset().top; let secBottom = $(section).offset().top + $(section).outerHeight(true); // width() ,height() DOM 內容寬高 // innerWidth() ,innerHeight() DOM 內容寬高 + padding 寬高 // outerWidth() ,outerHeight() DOM 內容寬高 + padding 寬高 + border 寬高 // outerWidth(true) ,outerHeight(true) // DOM 內容寬高 + padding 寬高 + border 寬高 + margin 寬高 if (sectionTop &gt;= top &amp;&amp; secBottom &gt;= top) &#123; target = index; // 中斷 return false; &#125; &#125;); $(".nav &gt; a") .removeClass("active") .eq(target) .addClass("active"); &#125;) .scroll(); $(".nav &gt; a").click(function() &#123; // this =&gt; 按到的按鈕 =&gt; js對象 // $(this) =&gt; jq對象 let index = $(this).index(); // 按鈕編號 let $target = $("#container &gt; section").eq(index); let position = $target.offset().top - $("#nav").outerHeight(true); $("html,body").animate(&#123; scrollTop: position &#125;, 500); &#125;); // $(".nav a") // .eq(0) // .addClass("active");&#125;)();]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript - 從零開始 Day1]]></title>
    <url>%2F2019%2F07%2F20%2FJS-Starting%20from%20scratch%20D1%2F</url>
    <content type="text"><![CDATA[第一天 你不可不知的那些小事情 - 生態現況與基本常識敘事與程式的關係故事 1:角色:Alex =&gt; fatherHoward =&gt; son故事:Howard =&gt; 肚子餓 =&gt; 叫爸爸 =&gt; Alex 煮飯 12345Howard.addEventListener(肚子餓,叫爸爸)叫爸爸() &#123; Alex.煮飯&#125; ECMAScript vs JavaScriptLiveScript 跟風 Java 改名 JavaScript ECMAScript 是規範版本的名稱 Ex : ECMAScript 6 網頁三腳督HTML + CSS + JavaScript Javascript 負責事情 1.功能操作 2.動畫 (能用 Css 做就用 Css 做)css 效能比較好用 3.資料處理 BOM vs DOMBOM(Browser Object Model):操作瀏覽器Ex: window.navigator , window.location … 等 DOM(Document Object Model):操作網頁內容(大部分是標籤)Ex: div, style … 等 tag資料處理一般在撰寫上要考量要操作哪部分 範例 1JavaScript 寫在哪裡? 都可以?位置: HTML 外面 HTML 裡面 HTML 裡面 HEAD 裡面 HTML 裡面 BODY 裡面 瀏覽器會將上面全都拉近 BODY 裡面 =&gt; 建議放在 BODY 結束前 script 包出一個區域做撰寫程式地方依照順序由上到下的方式去依序執行 最基本類型 文字 String 數字 Number 布林 Boolean 空值 Null 未定義 Undefined 如果 HTML 畫面完成再執行 document.write,會把整個畫面清掉從 write 範例 21.宣告:新增(取名字) 2.先宣告後使用！ （重要3.var(可改變) let(可改變) const(常數不會變) 4.資料轉換 5.作用域 1234567var a = 123; // 宣告 a 變數 等於 123// 宣告 a 變數，將 123 設定到 a 變數 //a = 2;console.log(a); //在console 面板印出內容 a += 2;(簡寫) =&gt; a = a + 2;(完整) //在不熟的狀態下不要用簡寫 12345678910111213141516171819202122232425262728293031323334353637383940//作用域範圍//建議使用let方式去宣告 (因為會鎖作用域)//function作用區塊 function example_var() &#123; console.log("===== var start ====="); console.log(a); // undefined var a = 1; console.log(a); // 1 a += 2; console.log(a); // 3 console.log("===== var end ====="); &#125; function example_let() &#123; console.log("===== let start ====="); console.log(a); // Error 不往下做 註解後可以往下做 let a = 1; console.log(a); a += 2; console.log(a); console.log("===== let end ====="); &#125; //常數 function example_const() &#123; console.log("===== const start ====="); const a = 1; console.log(a); // 1 a += 2; console.log(a); // Error 常數不可改 console.log("===== const end ====="); &#125; let a =&gt; undefined //不建議去這樣使用 let a ='' // 預設文字 String let b =null // 預設物件 Object let c =0 // 預設數字 Number let d = false // 預設布林值 Boolean let e = [] // 預設陣列 Array (有時設 null) 作用域使用Why 使用作用域 : 因為網頁內容若能被調整, 容易造成網頁內容不安全 blockes6 使用一對大括號{} =&gt;裡面只能用 let 跟 const IIFE(function(){…})(); function 函式宣告方式1.123function 函式名稱(...參數) &#123; //執行內容..&#125; 它會有提升 (hoisting) 現象，，像這樣： 1234greet();function greet() &#123; //執行內容..&#125; 2. 優點 函式在宣告時,才產生出來 較符合先宣告後使用的習慣 1234let xxx = function() &#123; // 宣告一個名稱設定一個function // ....&#125;; Chrome &amp; Vscode TipsChrome 下斷點記得要重新整理 vscode 快捷鍵左方小齒輪 -&gt; 中文 : 使用者程式碼片段 , 英文 : User Snippets 123456789"IIFE": &#123; "prefix": "iife", "body": [ "(function() &#123;", " $1", "&#125;)();" ], "description": "IIFE"&#125; vscode 顯示設定 (專案)1234567891011121314151617181920212223&#123; "editor.fontFamily": "Fira Code,Microsoft JhengHei", "editor.fontLigatures": true, "editor.fontSize": 14, //字體大小 "window.zoomLevel": 3, // 字體縮放大小 "editor.rulers" : [80,120] "prettier.printWidth": 120 // prettier 換行設定 (幾個字換行) "explorer.openEditors.visible": 0, // 旁邊檔案開的資料夾數 "files.autoSave": "afterDelay", "editor.formatOnSave": true, "editor.tabSize": 2, "editor.insertSpaces": true, "emmet.triggerExpansionOnTab": true, //觸發emmet "liveServer.settings.donotShowInfoMsg": true, "liveServer.settings.ignoreFiles": [".vscode/**", ".data/**"], &#125; Reference CodePen CodeSandbox - 線上編碼協作 Can I Use - 查詢相容性 優先性參考 那些該死的運算與轉換 - 資料類型與操作數學運算與回傳 運算式運算元(運算的值 ex:數字運算子(怎麼算 ex:+-= 賦值運算子 (一般都會改變內容) 1234567891011121314151617let a = 1 // 將1賦予aa += 1 // a = a + 1 =&gt; 2a -= 1 // a = a - 1 =&gt; 1a *= 10 // a = a * 10 =&gt; 10a /= 5 // a = a/5 =&gt; 2//a++ =&gt; a +=1 =&gt; a = a+1let b = a++ // 先做b=a (a賦值於b) 後做 a=a+1 a,b = 3,2let c = --a // 先做 a=a-1 後做 c=(a-1) 此時a-1已先算完，帶入C即可//a,b,c = 2,2,2let d1 = b+=1 // b,d1 = 3,3// 逗號 : 接著做let d2 = ( b+=1 , c+=2 , a+b+c) // a,b,c,d2 = 2,3,4,9let d =b+1,c+2,a+b+c // error 這部分切為 let d =b+1 (賦值) / c+2,a+b+c//除了a++ 這種剩下都是先算完再拿 += 跟++是不相等的 算術運算子 字串運算子 1234567如果有字串會字串優先;let x = 1 + "1"; // =&gt;"1"="1"=&gt;"11"let y = 1 + true; // =&gt; 1+1=&gt;2let z = 1 + !"3"; //=&gt; 1+!true =&gt; 1+false=&gt;1+0=&gt;1//上面會優先做驚嘆號部分 (反轉)3 + 1 + "2"; //=&gt; 4 + "2" =&gt; "42"3 + (1 + "2"); // =&gt; 3 + ("1" + "2") =&gt; 3 + "12" =&gt; "3" + "12" =&gt; "312" 轉換表 if 條件判斷式12345678910111213141516171819202122232425262728293031// 肚子餓// No.1 =&gt; 做事情或不做如果 肚子餓 =&gt; 吃if（肚子餓）&#123; 吃&#125;// No.2 =&gt; 做a or 做b如果 肚子餓 =&gt; 吃不然 =&gt; 不吃if( 肚子餓 ) &#123; 吃&#125;else&#123; 不吃&#125;// No.3 =&gt; 條件1 做A / 條件2 做B / 做C如果 肚子很餓 =&gt; 吃多一點不然如果 普通餓 =&gt; 吃一點點不然 不吃if( 肚子很餓 ) &#123; 吃多一點&#125;else if( 普通餓 )&#123; 吃一點點&#125;else&#123; 不吃&#125; 12345678910111213141516let 肚子 = 40;let 吃 = function() &#123; 肚子 += 20;&#125;;if (肚子 &lt; 60) &#123; 吃();&#125;console.log(肚子); // 60if (肚子 &lt; 60) &#123; 吃();&#125;console.log(肚子); // 60 12345678910let 肚子 = 60;let 吃 = function() &#123; 肚子 += 20;&#125;;if (肚子 &lt; 60) &#123; 吃();&#125; else &#123; 不吃(); // 當肚子40不會進來 如果60 會抱錯&#125; 123456789101112let 肚子 = 70;let 客製吃 = function(食物量) &#123; 肚子 += 食物量;&#125;;if (肚子 &lt;= 40) &#123; 客製吃(40);&#125; else if (肚子 &lt;= 60) &#123; 客製吃(20);&#125; else &#123; 客製吃(-10);&#125; 完整 Code (Alex 版)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 肚子餓let 肚子 = 40;let 吃 = function() &#123; 肚子 += 20;&#125;;let 不吃 = function() &#123; 肚子 -= 10;&#125;;// No.1 =&gt; 做事情 OR 不做//如果 肚子 &lt; 60 =&gt; 吃// if (肚子 &lt; 60) &#123;// 吃();// &#125;// console.log(肚子); // 60// if (肚子 &lt; 60) &#123;// 吃();// &#125;// console.log(肚子); // 60// No.2 =&gt; 做A OR 做B//如果 肚子餓 =&gt; 吃//不然 =&gt; 不吃// 肚子 = 60;// if (肚子 &lt;= 60) &#123;// 吃();// &#125; else &#123;// 不吃();// &#125;// console.log(肚子); // 80// No.3 =&gt; 條件1 做A 條件2 做B 做C//如果 肚子很餓 =&gt; 吃多一點//不然如果 普通餓 =&gt; 吃一點點//不然 不吃肚子 = 70;let 客製吃 = function(食物量) &#123; 肚子 += 食物量;&#125;;if (肚子 &lt;= 40) &#123; 客製吃(40);&#125; else if (肚子 &lt;= 60) &#123; 客製吃(20);&#125; else &#123; 客製吃(-10);&#125;console.log(肚子); // 60 switch 條件判斷式（進入點）12345678910111213141516let 肚子飢餓程度 = 4; // 4,3,2,1// 沒有break 會一路吃到底switch (肚子飢餓程度) &#123; case 4: console.log("20顆水餃"); break; case 3: console.log("三片披薩"); break; case 2: console.log("一個便當"); break; default: console.log("喝杯飲料");&#125;// 刷牙洗臉 =&gt; 換衣服 =&gt; 穿鞋 =&gt; 出門 補充 (二進位 與 Bitwise)12345678910111213141516171819// 二進位// 1:1// 2:10// 3:11// 4:100// 5:101let a = 2;let b = 5;console.log(a.toString(2), b.toString(2)); // 10,101// toString(2) -&gt; 2進位的意思// Bitwise10 &gt;&gt; 1; // 5 (去小數點除2) // 01010 的全部位元向右移動一位數變成 0010113 &lt;&lt; 1; // 26 //01101的全部位元向左移動一位數變成 1101013.9 &lt;&lt; 1; // 26 (去小數點乘2)20.8 &gt;&gt; 0; // 2020.3 &lt;&lt; 0; // 20// &gt;&gt;0 與 &lt;&lt;0 會無條件捨去小數點後面 寫程式建議步驟1.思考 2.畫圖 3.寫程式 範例 3 window window.alert ( 跳訊息 ) window.confirm ( 跳確認，回傳布林值 ) window.prompt ( 跳輸入框，回傳輸入內容 ) 1234567891011121314151617// 請輸入你的程式(function() &#123; let checkName = window.confirm("願意告訴我名字嗎?"); // true / false if (checkName) &#123; // 給 let input = window.prompt("請輸入名字"); // 輸入的內容 customHi(input); &#125; else &#123; // 不給 customHi("No Name"); &#125; function customHi(message) &#123; // window.alert("Hi!!! " + message); window.alert(`Hi!!! $&#123;message&#125;`); // ES6 寫法 &#125; // customHi("Alex");&#125;)(); 來人阿!開工吧 - DOM 與事件操作三劍客1.Who2.What3.When 認識 function 做點事加上小括號會馬上做所以在監聽後面不需要加括號ex: addEventListener(&quot;click&quot;, greeting); getElement 與 querygetElement:1.getElementById (效能較佳，但須考量效率)2.getElementByClassName =&gt; collection (動態更新/無法跑迴圈)3.getElementByTagName query:1.querySelector2.querySelectorAll =&gt; list (靜態不變/有 forEach) 事件範例 4123456789101112function greeting() &#123; let name = "無名氏"; if (window.confirm("願意告訴我你的稱呼嗎？")) &#123; // name = window.prompt("請輸入姓名：", "").trim() || name; // null.trim() =&gt; ERROR let input = window.prompt("請輸入姓名：", ""); // null,""," ","ALEX"," ALEX " name = (input &amp;&amp; input.trim()) || name; &#125; window.alert(`嗨，$&#123;name&#125;！`);&#125;trim =&gt; 可以使用這個來去頭尾; &amp;&amp; / ||可以拿來做判斷式 , 也能拿來流程控管 1234567891011121314151617// 有不做就不做case1 true &amp;&amp; case2 true // case1 與 case2 都會做 -&gt; 回傳case2 做case1 true &amp;&amp; case2 false // case1做 但 case2 不做 -&gt; 回傳case2 不做case1 false &amp;&amp; case2 true // case1不做 ,case2 做 -&gt; 回傳case1 不做case1 false &amp;&amp; case2 false // case1 與 case2 都不做 -&gt; 回傳case1 不做// 有中即離開case1 true || case2 true // case1中即離開 -&gt; 回傳case1 中case1 true || case2 false // case1中即離開 -&gt; 回傳case1 中case1 false || case2 true // case1沒中 ,但case2中 -&gt; 回傳case2 中case1 false || case2 false // case1 與 case2 都沒做 -&gt; 回傳false// 範例1&amp;&amp;2&amp;&amp;3 // =&gt; 31&amp;&amp;2||3 // =&gt; 2 // 2 中 且 後面為or運算子 ,即跳開1&amp;&amp;0||3 // =&gt; 3 // 數字0 Boolean為false1||2&amp;&amp;0 // =&gt; 1 後面為or運算子 ,即跳開3 &amp;&amp; 5 //=&gt; 53 || 5 //=&gt; 3 範例 5 程式盡量不要有大量相同的 Code =&gt; 整理 快速大量選取快捷鍵 =&gt; ctrl+d (選) ctrl+k(不選) 怎麼選東西很重要 forEach 參數名稱是自己取的 capture =&gt; target =&gt; bubble滑鼠進入/離開事件1.mouseover/mouseout =&gt;(1) 在乎的是 Taget (會產生畫面一直跳)(2) 會冒泡 (bubble)(3) addEventListener 把 useCapture 設 true 就會反向 Target : https://developer.mozilla.org/zh-TW/docs/Web/API/Event/target 2.mouseenter/mouseleave =&gt;(1) 在乎的是 currentTarget (綁定事件的東西)(2) 不會冒泡 (bubble) ***根據需要針對對象選擇 字串運算 =&gt; 先挖洞在左右補+ 123456789101112// querySelectorAll 迴圈處理document.querySelectorAll("img").forEach(img =&gt; &#123; img.addEventListener("mouseover", inHandler); img.addEventListener("mouseout", outHandler);&#125;);// getElementsByTagName 迴圈處理let imgs = document.getElementsByTagName("img");for (let i = 0; i &lt; imgs.length; i++) &#123; imgs[0].addEventListener("mouseover", inHandler); imgs[0].addEventListener("mouseout", outHandler);&#125; this 事件偵聽的 thiswho =&gt; when =&gt;what呼叫事件的人(currentTarget) 圖片的範例this =&gt; bronze currentTarget(e.currentTarget =&gt; 事件綁定的對象) 箭頭函式沒有 this this =&gt; js 對象 \$(this) =&gt; jq 對象 三元運算1234567check ? a : b;if (check) &#123; return a;&#125; else &#123; return b;&#125; current 綁定事件那一個target 最深那一層的 DOM mouseenter 不會有 bubble(不會有冒泡) alex example***使用 div.id.length 做判斷=&gt; 思考兩組需要綁定的差異，設定 id 長度不同，所以用這個來做區分 範例 6 要畫有幫助思考的流程圖(不同事件差異要出來 迴圈中寫 function 會產生多組重複 function substr : 切西瓜 (第一刀位置,切多少字) NodList 沒有 indexOf 要用 […NodeList] 轉成 List 轉數字 : *1 -0 /1 parseInt() 藍色是正確方式按(找人) =&gt; 換號(依照不同人用不同方式) =&gt; 換圖 substr(重哪裡切,切多寬) 當數字超過(過大或過小時)有兩種選擇:下面寫法為第一種選擇(1) 過大回到 0，過小回到最後 (一種迴圈)(2) 過大停在最後，過小停在 0 (前後不動) 1.改在 changeView() (改變選圖時) 1234567891011121314let imgLength = imges.length;// 判斷如果imgNumber超過圖片數量就歸0// 如果沒有再判斷是否有 &lt; 0 則改成圖片長度-1// 其他就維持不變imgNumber = imgNumber &gt;= imgLength ? 0 : imgNumber &lt; 0 ? imgLength - 1 : imgNumber;if (imgNumber &gt;= imgLength) &#123; imgNumber = 0;&#125; else if (imgNumber &lt; 0) &#123; imgNumber = imgLength - 1;&#125; else &#123; imgNumber = imgNumber;&#125; 2.改在產生 imgNumber 時(改計算時) 12345678910111213141516171819202122232425262728293031323334353637// imges.length = 5// prev// 4 =&gt; 3 =&gt; 2 =&gt; 1 =&gt; 0 =&gt; -1(x)// // 當過少時有兩種選擇// (1) 回到最後 (4 = imges.length-1)// (2) 回到開頭 (0)imgNumber = imgNumber - 1;if (imgNumber &lt; 0) &#123; imgNumber = imges.length - 1;&#125;// next// 0 =&gt; 1 =&gt; 2 =&gt; 3 =&gt; 4 =&gt; 5(x)// 當過多時有兩種選擇// (1) 回到開頭 (0)// (2) 回到最後 (4 = imges.length-1)imgNumber = imgNumber + 1;if (imgNumber &gt;= imges.length) &#123; imgNumber = 0;&#125;// 改成取餘數，餘數可以產生數量範圍內的編號// Ex: 所有數字 / 3 會產生的餘數 = 0,1,2// Ex: 所有數字 / 5 會產生的餘數 = 0,1,2,3,4// previmgNumber = (imgNumber - 1 + imges.length) % imges.length;// (0 - 1 + 5) % 5 = 4// (1 - 1 + 5) % 5 = 0// (2 - 1 + 5) % 5 = 1// (3 - 1 + 5) % 5 = 2// (4 - 1 + 5) % 5 = 3// nextimgNumber = (imgNumber + 1 + imges.length) % imges.length;// (0 + 1 + 5) % 5 = 1// (1 + 1 + 5) % 5 = 2// (2 + 1 + 5) % 5 = 3// (3 + 1 + 5) % 5 = 4// (4 + 1 + 5) % 5 = 0 // 結合 prev 跟 next 1234case "prev":case "next": imgNumber = ( imgNumber + (this.id === "prev" ? -1 : 1) + imges.length ) % imges.length ; break; 1234567891011let map = &#123; prev: -1, next: 1&#125;;switch (this.id) &#123; case "prev": case "next": imgNumber = (imgNumber + map[this.id] + images.length) % images.length; break;&#125; == 與 ===== : 等於=== : 完全等於 12345678let a = 1;let b = new Number(1);a == b; // truea === b; // falsetypeof a; // numbertypeof b; // object 箭頭函式() =&gt; {} // 一行時{}可以省略 1234567(msg =&gt; console.log(msg))(123);//((msg) =&gt; &#123;console.log(msg);&#125;)(123);// 相當於下面寫法function print(msg) &#123; console.log(msg);&#125;print(123); 這包東西不簡單 - 陣列與物件的管理應用一坨與一串東西的特性資料紀錄通常無法確認多語系要用哪個語言顯示，盡量使用中性資料 EX:數字 1234567891011121314151617181920212223// 物件 管理一個對象 (可以指向特定Key Key Value)let alex = &#123; name: "alex", age: 36, merry: true, sex: 1&#125;;let sara = &#123; name: "sara", age: 18, merry: true, sex: 0&#125;;// 陣列 管理一串資料 (只能知道先後順序 Index Value)let family = [alex, sara][ // 0 1 (alex, sara)].forEach((people, index) =&gt; &#123; console.log(people, index);&#125;); 範例 7 CSR(Client Side Rendom) VS SSR(Server Side Rendom)SSR:網頁檢視原始碼看到的(程式產資料)CSR:網頁檢視原始碼不一定看得到(資料產程式) 物件(一根香蕉) VS 陣列(一串香蕉) 陣列操作 計時器 setTimeout(做一次) / setInterval(一直做) 資料塞入 DOM =&gt; 初始化畫面 麥當勞點餐現在:點完去旁邊點餐 (非同步以前：點完好了再下一位（同步 遞迴 =&gt; 自己呼叫自己 範例 9 輸入 =&gt; 送出(button) =&gt; 抽籤 click(要自己檢查資料) / submit(form 送出) slice 切出新的陣列 / splice 切原始陣列 (處理陣列)slice 不改變原本陣列splice 會改變12 split 針對 string 處理切割 123456789101112131415let a = [1, 2, 3, 4, 5];console.log(a.slice(1, 2), a); // [2],[1,2,3,4,5]// slice 回傳陣列// 刪除index=1 刪除1個 再index=1插入alex// (刪除或插入位置,刪除個數,插入資料)a.splice(1, 1, "alex"); // [1,'alex',3,4,5]console.log(a);//split 針對字串let b = "1,2,3,4,5";let ary = b.split(",");console.log(ary); // ['1','2','3','4','5']let ary2 = b.split("3");console.log(ary2); // ["'1,2,'","',4,5'"] 你怎麼說我怎麼做 - 條件判斷與流程控制for 迴圈 vs while 迴圈12345678910111213141516171819202122232425262728293031let ary = [1, 2, 3, 4, 5];// For迴圈let forCount = 0;for (let i = 0; i &lt; ary.length; i++) &#123; forCount = forCount + ary[i];&#125;console.log(forCount);// While迴圈let whileCount = 0;let temp = [...ary];while (temp.length) &#123; whileCount += temp.shift();&#125;console.log(whileCount);// ForEachlet foreachCount = 0;ary.forEach(num =&gt; &#123; foreachCount += num;&#125;);console.log(foreachCount);// 上面都需要宣告一個值才能開始// Reduce preVal:上次值 ,currentVal:這次值 ,逗號後面是預設值(0)let reduceCount = ary.reduce((preVal, currentVal) =&gt; &#123; console.log(preVal, currentVal); return preVal + currentVal;&#125;, 0); // 這個0就是初始值console.log(reduceCount); 遞迴1.往前走(呼叫自己) 2.有 return 條件 3.邊界條件 範例 10 階乘 輸入 5 拿到(5!) 5 _ 4 _ 3 _ 2 _ 1 12345678910111213141516171819202122232425262728293031// forfunction example1(num) &#123; let n = 1; for (let i = num; i &gt; 1; i--) &#123; // 5 5 &gt; 1 5-- // 4 4 &gt; 1 4-- // 3 3 &gt; 1 3-- n *= i; &#125; return n;&#125;console.log(example1(5));// recursion// 遞迴不會有for複雜的邏輯，取而代之是更複雜的邏輯// 1.往前走(呼叫自己) : example1_re(num - 1)// 2.有return條件// 3.邊界條件 : num &lt;= 1function example1_re(num) &#123; if (num &lt;= 1) return 1; // 邊界條件 return num * example1_re(num - 1);&#125;console.log(example1_re(5));// 5 * example1_re(4)// 5 * 4 * example1_re(3)// 5 * 4 * 3 * example1_re(2)// 5 * 4 * 3 * 2 * example1_re(1)// 5 * 4 * 3 * 2 * 1 fibonacci : 前兩個是 1，第三個開始為前兩個和 12345678910111213141516171819// 使用while迴圈取出fibonaccifunction fibonacci(num) &#123; // 前兩位是1 if (num &lt;= 2) return 1; let n1 = 1; // 第一位 let n2 = 1; // 第二位 let temp = n1 + n2; // 第三位 // 因為有三位所以只要算到n-2位 // 1-&gt;n-2,2-&gt;n-1,3-&gt;n // 為了要算到第n-2位，一直--到剩下2 while (num &gt; 2) &#123; temp = n1 + n2; // 算出下一位(前兩位和) n1 = n2; // 將第二位當成第一位 n2 = temp; // 將第三位當成第二位 // 一直往後平移 num--; &#125; return temp;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//EX: fibonacci(5)//fibonacci(5) =&gt; 1 1 2 3 [5]// n1 n2 temp (迴圈第一次)// n1 n2 temp (迴圈第二次)// n1 n2 temp (迴圈第三次)// 第一段判斷if (5 &lt;= 2) return 1; // 5不小於等於2繼續往下// 初始化資料let n1 = 1; // 第一位let n2 = 1; // 第二位let temp = n1 + n2; // 第三位//進入迴圈時//第一次while (5 &gt; 2) &#123; temp = n1 + n2; // (1+1 = 2) n1 = n2; //(1) n2 = temp; // (2) num--; // num = 5-1&#125;//第二次while (4 &gt; 2) &#123; temp = temp + n1; // (1+2=3) n1 = n2; //(2) n2 = temp; // (3) num--; // num = 4-1&#125;//第三次while (3 &gt; 2) &#123; temp = temp + n1; // (2+3=5) n1 = n2; //(3) n2 = temp; // (5) num--; // num = 3-1&#125;//第四次while (2 &gt; 2) &#123; // 條件不成立跳出迴圈 temp = temp + n1; n1 = n2; n2 = temp; num--;&#125;return temp; // 5]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-07-Array Cardio Day 2]]></title>
    <url>%2F2019%2F05%2F09%2FJS30-07-Array%20Cardio%20Day%202%2F</url>
    <content type="text"><![CDATA[陣列的操作some()、every()、find()、findIndex()、slice()、splice() 目標 由二組資料中，根據不同需求條件篩選出正確的資料 12345678910111213- const people = [ &#123; name: 'Wes', year: 1988 &#125;, &#123; name: 'Kait', year: 1986 &#125;, &#123; name: 'Irv', year: 1970 &#125;, &#123; name: 'Lux', year: 2015 &#125; ];- const comments = [ &#123; text: 'Love this!', id: 523423 &#125;, &#123; text: 'Super good', id: 823423 &#125;, &#123; text: 'You are the best', id: 2039842 &#125;, &#123; text: 'Ramen is my fav food ever', id: 123523 &#125;, &#123; text: 'Nice Nice Nice!', id: 542328 &#125; ]; 實作要點 利用 some()，判斷 people 中是否有 19 歲以上的人。 利用 every()，判斷 people 中是否都 19 歲以上。 利用 find()，找到 comments 中 id 是 823423 的資料。 利用 findIndex()，找出 comments 中 id 是 823423 的索引值。 利用 splice()、slice 刪除 comments 中 id 是 823423 的資料。 實作判斷 people 中是否有 19 歲以上的人→ some()Array.prototype.some()12345const ans0 = people.some(p =&gt; new Date().getUTCFullYear() - p.year &gt;= 19);//some() 方法會測試陣列中是否[至少有一個]元素通過由給定之函式所實作的測試。//若回呼函式在處理任何一個陣列元素時得到 truthy 值，則回傳 true。否則，回傳值為 false。console.log(ans0);console.log('↑↑ is at least one person 19 or older? ↑↑'); MDN-Array​.prototype​.some() 判斷 people 中是否都 19 歲以上→ every()Array.prototype.every()12345const ans1 = people.every(p =&gt; new Date().getUTCFullYear - p.year &gt;= 19);//every() 方法會測試陣列中的[所有]元素是否都通過了由給定之函式所實作的測試。//若回呼函式在處理每一個陣列元素時皆得到 truthy 值，則回傳 true。否則，回傳值為 false。console.log(ans1);console.log('↑↑ is everyone 19 or older? ↑↑'); MDN-Array​.prototype​.every() 找到 comments 中 id 是 823423 的資料→ find()Array.prototype.find()12345//find() 方法會回傳第一個滿足所提供之測試函式的元素值。否則回傳 undefined。//若元素通過測試則為其值；否則為 undefined。const ans2 = comments.find(comment =&gt; comment.id === 823423);console.log(ans2);console.log('↑↑ find the comment with the ID of 823423 ↑↑'); MDN-Array​.prototype​.find() 找出 comments 中 id 是 823423 的索引值→ findIndex()Array.prototype.findIndex()123const ans3 = comments.findIndex(comment =&gt; comment.id === 823423);console.log(ans3);console.log('↑↑ Find the comment 位置 with this ID of 823423 ↑↑'); MDN-Array​.prototype​.find​Index() 刪除 comments 中 id 是 823423 的資料→ slice() slice 為 淺拷貝（shallow copy），不影響原陣列資料(取得新的陣列資料)。 Array.prototype.slice()12345const ans4 = comments.slice(0, ans3); //切ans3之前的const ans5 = comments.slice(ans3 + 1); //切ans3之後的const ans6 = [...ans4, ...ans5]; //然後再合併 [Spread syntax(展開語法)]console.log(ans6, comments);console.log('↑↑ delete the comment with the ID of 823423 (用slice做) ↑↑'); MDN-Array​.prototype​.slice() → splice() splice 為 直接處理現有的陣列資料 Array.prototype.splice()12345const ans8 = comments.splice(ans3, 1); //ans8就是刪掉的東西，沒留就不見了。console.log(comments);console.log('↑↑ delete the comment with the ID of 823423 (用splice做) ↑↑');console.log(ans8);console.log('↑↑ 被刪掉的東西 ↑↑'); MDN-Array​.prototype​.splice()]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-05-Flex Panel Gallery]]></title>
    <url>%2F2019%2F04%2F30%2FJS30-05-Flex-Panel-Gallery%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-04-Array Cardio Day 1]]></title>
    <url>%2F2019%2F04%2F29%2FJS30-04-Array-Cardio-Day-1%2F</url>
    <content type="text"><![CDATA[陣列的操作filter()、map()、reduce()、sort() 目標 / 題目 使用 array.prototype 依據不同需求條件使用不同的 method 篩選出正確的資料。 題目 1~5. 對inventors資料做篩選。 1234567891011121314const inventors = [&#123; first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 &#125;,&#123; first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 &#125;,&#123; first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 &#125;,&#123; first: 'Marie', last: 'Curie', year: 1867, passed: 1934 &#125;,&#123; first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 &#125;,&#123; first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 &#125;,&#123; first: 'Max', last: 'Planck', year: 1858, passed: 1947 &#125;,&#123; first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 &#125;,&#123; first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 &#125;,&#123; first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 &#125;,&#123; first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 &#125;,&#123; first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 &#125;,]; 題目 6. 列出網址中所有包含’de’的路名。網址：連結 題目 7. 依據lastName排序所有people的資料。 1const people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Beethoven, Ludwig', 'Begin, Menachem', 'Belloc, Hilaire', 'Bellow, Saul', 'Benchley, Robert', 'Benenson, Peter', 'Ben-Gurion, David', 'Benjamin, Walter', 'Benn, Tony', 'Bennington, Chester', 'Benson, Leana', 'Bent, Silas', 'Bentsen, Lloyd', 'Berger, Ric', 'Bergman, Ingmar', 'Berio, Luciano', 'Berle, Milton', 'Berlin, Irving', 'Berne, Eric', 'Bernhard, Sandra', 'Berra, Yogi', 'Berry, Halle', 'Berry, Wendell', 'Bethea, Erin', 'Bevan, Aneurin', 'Bevel, Ken', 'Biden, Joseph', 'Bierce, Ambrose', 'Biko, Steve', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William']; 題目 8. 列出data內每個種類的數量。 1const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ]; 實作要點 利用 filter()，過濾出 1500 年代出生的人。 利用 map()，得到一個陣列(inventors’ first and last names)。 利用 sort()，將陣列的「birthdate」資料由大至小排序(inventors’s birthdate, oldest to youngest) 利用 reduce()，加總所有人的年齡。 利用 sort()，將陣列資料依年齡大小作排序。 利用 filter()，列出 wiki 資料中所有包含’de’的路名 利用 sort()，將 people 的資料依 lastName 做排序。 利用 reduce()，計算 data 內每個種類的數量。 實作1. 過濾出 1500 年代出生的人→ filter()Array.prototype.some()1234567891011const ans1 = inventors.filter(function(inventor) &#123; if (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600) &#123; return true; &#125;&#125;);//ES6 箭頭函數const ans11 = inventors.filter(inventor =&gt; inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600);console.table(ans11);console.log("↑↑ Filter the list of inventors for those who were born in the 1500's ↑↑"); MDN-Array​.prototype​.filter() 2. 將 inventors 的 first 和 last 組成陣列→ map()Array.prototype.map()123456789101112const ans2 = inventors.map(function(inventor) &#123; return inventor.first + ' ' + inventor.last;&#125;);//ES6 箭頭函數const ans22 = inventors.map(inventor =&gt; inventor.first + ' ' + inventor.last);//ES6 樣板字面值（Template literals）const ans222 = inventors.map(inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`);console.table(ans222);console.log("↑↑ Give us an array of the inventors' first and last names ↑↑"); → forEach()Array.prototype.forEach()12345//要自己產一個陣列，並將值推進去let ans2222 = []; inventors.forEach(function(inventor) &#123; ans2222.push(`$&#123;inventor.first&#125; $&#123;inventor.last&#125;`);&#125;); MDN-Array​.prototype​.map()MDN-Array​.prototype​.foreach() 3. 將 inventors 的 birthdate 由大到小排序→ sort()語法：arr.sort([compareFunction])- 若 compareFunction(a, b) 的回傳值小於 0，則會把 a 排在小於 b 之索引的位置，即 a 排在 b 前面。- 若 compareFunction(a, b) 回傳 0，則 a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。- 若 compareFunction(a, b) 的回傳值大於 0，則會把 b 排在小於 a 之索引的位置，即 b 排在 a 前面。1234567const ans33 = inventors.sort(function(a, b) &#123; return a.year - b.year;&#125;);//簡寫const ans333 = inventors.sort((a, b) =&gt; (a.year &gt;= b.year ? 1 : -1)); //三元運算子console.table(ans333);console.log('↑↑ Sort the inventors by birthdate, oldest to youngest ↑↑');MDN-Array​.prototype​.sort() 4. 加總所有人的年齡→ reduce()1234const ans4 = inventors.reduce(function(total, inventor) &#123; return (total += inventor.passed - inventor.year);&#125;, 0);console.log(ans4); MDN-Array​.prototype​.reduce() 5. 將陣列資料inventors依年齡大小作排序123456789const ans5 = inventors.sort(function(a, b) &#123; return a.passed - a.year - (b.passed - b.year);&#125;);//直接寫一個年齡/yesrs進到物件中比較好看出結果是否正確inventors.forEach(inventor =&gt; &#123; inventor.years = inventor.passed - inventor.year;&#125;);console.table(ans5);console.log('↑↑ Sort the inventors by years lived ↑↑'); 6. 利用 filter()，列出 wiki 資料中所有包含’de’的路名1234567//先取出路名變為陣列let Ary = [];document.querySelectorAll('.mw-category-group li a').forEach((a)=&gt;&#123; Ary.push(a.title)&#125;)//再利用filter取出符合條件的Ary.filter(title=&gt;title.indexOf('de')!=-1) 7. 利用 sort()，將 people 依 lastName [字母順序]做排序。12345678910let ans7 = people.sort((a, b) =&gt; &#123; let [aFirst, alast] = a.split(', '); //ES6 解構賦值 表示split後的值分別給 aFirst 跟 alast let [bFirst, blast] = b.split(', '); //ES6 解構賦值 表示split後的值分別給 bFirst 跟 blast //alast[0] ==&gt; 僅對第一個字母做排序，其後順序不變 (Aneurin會排在Ambrose前面) //return alast[0] &gt; blast[0] ? 1 : blast[0] &gt; alast[0] ? -1 : 0; //alast ==&gt; 整個單字做排序 (Ambrose會排在Aneurin前面) return alast &gt; blast ? 1 : blast &gt; alast ? -1 : 0; //三元運算子 [條件?條件成立:條件不成立]&#125;);console.table(ans7);console.log('↑↑ Sort the people alphabetically by last name ↑↑'); 8. 利用 reduce()，計算 data 內每個種類的數量。123456const ans8 = data.reduce((obj, content) =&gt; &#123; if (!obj[content]) obj[content] = 1; else obj[content] += 1; return obj;&#125;, &#123;&#125;);console.table(ans8); 總結 filter() ==&gt; 回傳一個陣列 map() ==&gt; 回傳一個陣列 sort() ==&gt; 回傳一個陣列 reduce() ==&gt; 回傳一個值]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS30-01-JavaScript-Drum-Kit]]></title>
    <url>%2F2019%2F04%2F25%2FJS30-01-JavaScript-Drum-Kit%2F</url>
    <content type="text"><![CDATA[使用鍵盤事件，觸發聲音及特效 目標 按下鍵盤時，播放聲音並顯示 CSS 效果。 播放完畢後，移除 CSS 效果。 實作要點 利用 JS addEventListener 監聽鍵盤的keydown Event 由按下鍵盤的 keyCode 選取出相對應的的 audio標籤 和 div標籤 audio 標籤 → 取得音效資源播放聲音 div 標籤 → 套用 CSS 效果 監聽 CSS 的 transitionend Event (transitionend 事件會在 transition 结束之後觸發) e.propertyName !== &quot;transform&quot; 僅針對 transform 繼續做事，不是則停止 若為 transform，則移除 CSS 效果 成品展示 [CodePen] JS 學習紀錄HTML5 標籤 HTMLMediaElement透過 js 取得 HTMLMediaElement 元素，來進行影音的播放。 HTML1&lt;audio data-key="65" src="sounds/clap.wav"&gt;&lt;/audio&gt; JS123456//取得 HTMLMediaElement 元素const audio = document.querySelector(`audio[data-key="$&#123;e.keyCode&#125;"]`); //ES6if (audio) &#123; audio.currentTime = 0; //持續撥放，設置或返回媒體中的當前播放位置（以秒 Seconds 為單位） audio.play(); // 播放音效&#125; MDN-HTMLMediaElementHTMLMediaElement.playHTMLMediaElement.currentTime DOM 元素 Element.classList透過 classList 新增、移除、切換 CSS 屬性，同等於 jQuery 的 addClass、removeClass。 HTML1234&lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt;&lt;/div&gt; JS123456//取得 DOM 元素const dom = document.querySelector(`div[data-key="$&#123;e.keyCode&#125;"]`); //ES6if (dom) key.classList.add('playing'); //新增CSS屬性key.classList.remove('playing'); //移除CSS屬性key.classList.toggle('playing'); //切換CSS屬性 Element.classList DOM 元素 NodeList使用 querySelectorAll 取得的 DOM 是 NodeList 型態，非 Array 型態，雖然 也可以使用 NodeList.prototype.forEach() 的 method，但有可能會遇到部份瀏覽器不支援，所以一般來說為了相容性，會先轉換成 Array 型態再拿來做使用。 HTML12345678&lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt;&lt;/div&gt;&lt;div data-key="83" class="key"&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class="sound"&gt;hihat&lt;/span&gt;&lt;/div&gt; JS12345// querySelectorAll 取得 DOM 元素 → NodeList 型態const keys = document.querySelectorAll('.key');// NodeList.prototype.forEach() → IE不支援keys.forEach(key =&gt; key.addEventListener('transitionend', transitionEndHandler)); 可藉由下列方法，將 NodeList 轉換 Array 型態，支援度較高。 NodeList 轉換 Array12345// Array.from() 轉Array型態const keys = Array.from(document.querySelectorAll('.key'));// 轉換成 Array型態 後，就可以使用 forEach()、map(), concat() …等methodkeys.forEach(key =&gt; key.addEventListener('transitionend', transitionEndHandler)); NodeList.prototype.forEach()Array.from() 也可以使用 ES6 … 展開運算子(Spread Operator) JS 展開運算子123// ...展開運算子const keys = [...document.querySelectorAll('.key'))];keys.forEach(key =&gt; key.addEventListener('transitionend',transitionEndHandler)) … 展開運算子(Spread Operator) 監聽 CSS transitionend 事件transitionend 事件會在 CSS transition 結束後觸發 JS12345678function transitionEndHandler(e) &#123; //因為CSS class [.key]做了transition: all，會使多個CSS效果同時執行。 //監聽transitionend時會發現觸發了很多次，ex:border-left-color、border-right-color、transform... //我們只需要對transform事件做處理 if (e.propertyName == 'transform') &#123; e.currentTarget.classList.remove('playing'); //currentTarget ==&gt; 事件綁定的對象 或用Target也行。 &#125;&#125; transitionendMDN-Event reference 查詢鍵盤的代碼]]></content>
      <categories>
        <category>JS</category>
        <category>JS30</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JS30</tag>
      </tags>
  </entry>
</search>
